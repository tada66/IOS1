#!/bin/bash
# xhorakt00 Tadeas Horak
# 7. 3. 2024

export POSIXLY_CORRECT=yes
export LC_ALL=C

DATE_TIME_REGEX="^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2}) ([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2})$"     #will check if the date and time is in the correct format (YYYY-MM-DD HH:MM:SS)

HELP="0" #dont like this :( but it doesn't work without it :((
AFTER=""
BEFORE=""
CURRENCY=""
filterOUT=""
SortedCurrArr=()
SortedCurrAmountArr=()

help(){
    echo "xtf [-h|--help] [FILTR] [PŘÍKAZ] UŽIVATEL LOG [LOG2 [...]"
    echo "PŘÍKAZ může být jeden z:
list – výpis záznamů pro daného uživatele.
list-currency – výpis seřazeného seznamu vyskytujících se měn.
status – výpis skutečného stavu účtu seskupeného a seřazeného dle jednotlivých měn.
profit – výpis stavu účtu zákazníka se započítaným fiktivním výnosem.
FILTR může být kombinace následujících:
-a DATETIME – after: jsou uvažovány pouze záznamy PO tomto datu a čase (bez něj). DATETIME je formátu YYYY-MM-DD HH:MM:SS.
-b DATETIME – before: jsou uvažovány pouze záznamy PŘED tímto datem a časem (bez něj).
-c CURRENCY – jsou uvažovány pouze záznamy odpovídající dané měně.
-h a --help vypíšou nápovědu s krátkým popisem každého příkazu a přepínače."
exit 0
}

filter(){
    USER=$1
    FILE=$2     #get the user and file from arguments passed to the function
    if [[ ! -f "$FILE" ]] ; then
        exit 1
    fi
    AWKARG="\$1 == user"    #variable to store the eventual argument for awk
    if [[ -n $AFTER ]]; then
        AWKARG+=" && \$2 > after"
    fi
    if [[ -n $BEFORE ]]; then
        AWKARG+=" && \$2 < before"
    fi
    if [[ -n $CURRENCY ]]; then
        AWKARG+=" && \$3 == currency"
    fi
    filterOUT=$(awk -v user="$USER" -v after="$AFTER" -v before="$BEFORE" -v currency="$CURRENCY" -F ';' "$AWKARG" "$FILE")   #according to the interwebz there's no way to return a string, much less an array, and that this is just how it's done in shell, not sure if i like this
}

getCurrency(){
    filter "$1" "$2"  #call filter to get filterOUT based on arguments
    UnsortedMultiCurr=$(echo "$filterOUT" | awk -F';' '{print $3}')    #save all the currencies left after filtering
    readarray -t UnsortedMultiCurrArr <<<"$UnsortedMultiCurr"    #split results from awk by new line into elements in an array $UnsortedMultiCurrArr
    UnsortedCurrArr=() #Array without possible duplicates
    i=0
    for elementM in "${UnsortedMultiCurrArr[@]}"
    do
        found=0
        for elementS in "${UnsortedCurrArr[@]}"
        do
            if [[ "$elementM" == "$elementS" ]] ; then      #possible duplicates were removed
                found=1
            fi
        done
        if [[ "$found" == "0" ]] ; then
            UnsortedCurrArr[$i]="$elementM"
            i=$((i+1))
        fi
    done
    SortedCurr=$(printf "%s\n" "${UnsortedCurrArr[@]}" | sort)   #results sorted by sort utility, it needs to be fed with values separated by new lines, hence the use of printf instead of echo
    readarray -t SortedCurrArr <<<"$SortedCurr"
}

status(){
    getCurrency "$1" "$2" #call filter to get filterOUT based on arguments
    CurrNames=$(echo "$filterOUT" | awk -F';' '{print $3}')    #save all the currency names left after filtering
    readarray -t CurrNameArr <<<"$CurrNames"    #split results from awk by new line into elements in an array CurrNameArr
    CurrAmounts=$(echo "$filterOUT" | awk -F';' '{print $4}')
    readarray -t CurrAmountArr <<<"$CurrAmounts"
    j=0
    if [[ -z "${CurrNameArr[*]}" ]] || [[ -z "${SortedCurrArr[*]}" ]] ; then
        exit 1
    fi
    for CurrName in "${CurrNameArr[@]}"
    do
        i=0
        for SortedCurrName in "${SortedCurrArr[@]}"
        do
            if [[ "$SortedCurrName" == "$CurrName" ]] ; then
                SortedCurrAmountArr[$i]=$(awk "BEGIN { printf \"%.4f\", ${SortedCurrAmountArr[$i]} + ${CurrAmountArr[$j]}; }")     #this would be better with bc but i dont have that in my shell
            else 
                i=$((i+1))
            fi
        done
        j=$((j+1))
    done
}

profit(){
    echo "not implemented yet!"
}

while getopts ":-:a:b:c:h" opt #a+arg, b+arg, c+arg, h (no arg), -+arg (used for --help)
do 
    case "$opt" in 
        h)
            HELP="1"    #tried to do this with OPTIND != 2, but it just refuses to work, idk just kill me
            ;;
        -)  
            case $OPTARG in 
                help)       #only accepting --help
                    help
                    ;;
                *)
                    echo "Invalid syntax" >&2
                    exit 1
            esac
            ;;
        a)
            if [[ ! "$OPTARG" =~ $DATE_TIME_REGEX ]] ; then
                echo "Incorrect date or time format!" >&2
                exit 1
            fi
            AFTER=$OPTARG
            ;;

        b)
            if [[ ! "$OPTARG" =~ $DATE_TIME_REGEX ]] ; then
                echo "Incorrect date or time format!" >&2
                exit 1
            fi
            BEFORE=$OPTARG
            ;;

        c) CURRENCY=$OPTARG
           ;;

        *)
            echo "Invalid syntax" >&2
            exit 1
            ;;
    esac
done
if [ "$HELP" -eq "1" ] ; then
    help
fi
if [ -n "$AFTER" ] ; then
    shift 2
fi
if [ -n "$BEFORE" ] ; then
    shift 2
fi
if [ -n "$CURRENCY" ] ;  then
    shift 2
fi

case "$1" in 
    list)   
        filter "$2" "$3"
        if [[ -n "$filterOUT" ]] ; then
            echo "$filterOUT"
        fi
        ;;
    list-currency)
        getCurrency "$2" "$3"
        if [[ -n "${SortedCurr[*]}" ]] ; then
            echo "${SortedCurr[@]}"              #dont print if no results were found, would result in an empty line
        fi
        ;;
    status)
        status "$2" "$3"
        i=0
        for SortedCurrName in "${SortedCurrArr[@]}"
        do 
            echo "$SortedCurrName : ${SortedCurrAmountArr[$i]}"
            i=$((i+1))
        done
        ;;
    profit)
        profit
        ;;
    *)  
        filter "$1" "$2"
        echo "$filterOUT"
        ;;
esac
exit 0